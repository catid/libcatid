/*
	Copyright (c) 2009 Christopher A. Taylor.  All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice,
	  this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice,
	  this list of conditions and the following disclaimer in the documentation
	  and/or other materials provided with the distribution.
	* Neither the name of LibCat nor the names of its contributors may be used
	  to endorse or promote products derived from this software without
	  specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef CAT_SPHYNX_TRANSPORT_HPP
#define CAT_SPHYNX_TRANSPORT_HPP

#include <cat/net/ThreadPoolSockets.hpp>
#include <cat/threads/Mutex.hpp>
#include <cat/crypt/tunnel/AuthenticatedEncryption.hpp>

namespace cat {


namespace sphynx {


/*
	For my online game, I have decided to build an efficient transport layer for real-time and streaming messages based on UDP sockets.

	My game traffic will not be like normal TCP traffic, since it will be bursty and it will have real-time requirements.

	Based on what I have envisioned needing for my game, the following protocol is being used after spending weeks looking at alternatives and false-starts.  It provides MTU discovery, time synchronization, a reliable ordered stream, and real-time unreliable delivery.

	First, some terminology:
	Packet: IP|UDP|Encrypted payload stack.
	Datagram: Decrypted UDP payload from packet.
	Message: One message block from the datagram.

	All multi-byte fields are in little-endian byte order.


	Packet format on top of UDP header:
		 E { HDR(2 bytes)|DATA || HDR(2 bytes)|DATA || ... } || IV(3 bytes)|MAC(8 bytes)

	   E: ChaCha-12 stream cipher.
	   IV: Initialization vector used by security layer (Randomly initialized).
	   MAC: Message authentication code used by security layer (HMAC-MD5).

	   HDR|DATA: A message block inside the datagram.


	Each message follows the same format.  A two-byte header followed by data.

		 --- Message Header  (16 bits) ---
		  0 1 2 3 4 5 6 7 8 9 a b c d e f
		 <-- LSB ----------------- MSB -->
		 |   DATA.BYTES(11)    |R|I| SOP |
		 ---------------------------------

	   DATA.BYTES: Number of bytes in data part of message.
	   R: Reliable, ordered message.
	   I: Contains ACK-ID for remaining reliable messages.
	   SOP: Super opcode indicating the purpose of the message.


	The super opcodes:

	enum SuperOpCode
	{
	  SOP_MTU_PROBE,  // MTU probe packet (unreliable)
	  SOP_MTU_UPDATE,  // MTU update (reliable)
	  SOP_TIME_PING,  // Time synchronization ping (unreliable)
	  SOP_TIME_PONG,  // Time synchronization pong (unreliable)
	  SOP_DATA,    // Data (reliable or unreliable)
	  SOP_FRAG,    // Data fragment (reliable); initial fragment begins with 16-bit total length
	  SOP_ACK,    // Acknowledgment of reliable, ordered messages (unreliable)
	  SOP_NAK    // Negative-acknowledgment of reliable, ordered messages (unreliable)
	};


	MTU Probe and MTU Update are described in a previous post (http://catid.mechafetus.com/news/news.php?view=203).  MTU Update will set the R bit so that it can be delivered reliably.  A 1500 MTU packet is sent and a 1400 MTU packet is sent.  Both are sent by the client twice shortly after connection completes, at 8 second intervals.  The server and client will use the largest MTU that makes it across.

	MTU Probe format:
	  HDR(2) RandomBytes(MTU-overhead)

	  The probe is only sent by the client, and RandomBytes are generated by a CSPRNG.
	  This message is delivered unreliably.

	MTU Update format:
	  HDR(2) [ACKID(3)] PayloadLength(2)

	  ACKID: Acknowledgment number.  Optionally included before the user data if the [I] bit is set in the header.

	  PayloadLength is the length of the received RandomBytes + 2, to indicate the maximum bytes that can be used for headers and data in a packet.
	  This message is delivered reliably.


	Time Ping and Time Pong are basic millisecond-resolution timestamps used for time synchronization.  They're necessarily unreliable.  The pings are sent by the client at 5 second intervals for the first 40 seconds, and at 20 second intervals after that.  This allows the client to start sending messages using server-side timestamps.

	Time Ping format:
	  HDR(2) Client_MSecTSC(4)

	  The ping is only sent by the client.  The 32-bit field is a millisecond-resolution timestamp counter.
	  This message is delivered unreliably.

	Time Pong format:
	  HDR(2) Client_MSecTSC(4) Server_MSecTSC(4)

	  This message repeats the client's counter and attaches the server's counter.
	  This message is delivered unreliably.


	Data is user data that fits in a single message.

	Data format:
	  HDR(2) [ACKID(3)] UserData(X)

	  ACKID: Acknowledgment number.  Optionally included before the user data if the [I] bit is set in the header.

	  This message is delivered reliably or unreliably.


	Data Fragments are necessarily reliable and are processed after complete reassembly at the receiver.  The first fragment message in a series will start with a 16-bit length field to represent the length of the complete message.  I intend to support fragmented messages up to 65535 bytes in size.  File transfers will be implemented at a higher layer; this is mainly for transport efficiency so that I can make full use of the datagram payload space.

	Data Fragment format:
	  HDR(2) [ACKID(3)] [LENGTH(2)] UserDataFragment(X)

	  ACKID: Acknowledgment number.  Optionally included before the user data if the [I] bit is set in the header.
	  LENGTH: Length of complete message after all fragments are collected.  Allows receiver to allocate a buffer for the message once instead of growing a buffer.  This field is only included in the first data fragment.

	  This message is delivered reliably to insure reconstructed order.


	ACK messages allow the sender to free memory for transmitted reliable packets.  The absence of an ACK for RTT*4 indicates loss and causes the sender to begin retransmission.  The first acknowledgment of a packet provides a measurement of RTT (round-trip time).

	Acknowledgment format:
	  HDR(2) ROLLUP(3) [START1(3) END1(3) [START2(3) END2(3) [...]]]

	  ROLLUP: Acknowledge all messages up to but not including this ID.
	  START1/END1: A range of messages to acknowledge that are ahead of the ROLLUP.  This indicates loss or re-ordering.

	  This message is delivered unreliably.


	NAK messages are sent by the receiver to indicate loss.  This allows the sender to retransmit before the usual RTT*4 delay, which improves reaction time to loss and increases throughput.

	Negative-acknowledgment message format:
	  HDR(2) START1(3) END1(3) [START2(3) END2(3) [...]]

	  START1/END1: A range of messages to NAK.  This indicates loss.


	Flow control is still up in the air.  I'll probably do basic AIMD and worry about it after the game is being played. 
*/


class Connection;
class Map;
class Server;
class ServerWorker;
class ServerTimer;
class Client;
class Transport;

// Protocol constants
static const u32 PROTOCOL_MAGIC = 0xC47D0001;
static const int PUBLIC_KEY_BYTES = 64;
static const int PRIVATE_KEY_BYTES = 32;
static const int CHALLENGE_BYTES = PUBLIC_KEY_BYTES;
static const int ANSWER_BYTES = PUBLIC_KEY_BYTES*2;
static const int HASH_TABLE_SIZE = 32768; // Power-of-2
static const int MAX_POPULATION = HASH_TABLE_SIZE / 2;

// (multiplier-1) divisible by all prime factors of table size
// (multiplier-1) is a multiple of 4 if table size is a multiple of 4
// These constants are from Press, Teukolsky, Vetterling and Flannery's
// "Numerical Recipes in FORTRAN: The Art of Scientific Computing"
static const int COLLISION_MULTIPLIER = 71*5861 * 4 + 1;
static const int COLLISION_INCREMENTER = 1013904223;


// Handshake packet types
enum HandshakeTypes
{
	C2S_HELLO,
	S2C_COOKIE,
	C2S_CHALLENGE,
	S2C_ANSWER,
	S2C_ERROR
};

// Message opcodes
enum HandshakeErrors
{
	ERR_SERVER_FULL
};

// Super opcodes
enum SuperOpCode
{
	SOP_MTU_PROBE,	// MTU probe packet (unreliable)
	SOP_MTU_UPDATE,	// MTU update (reliable)
	SOP_TIME_PING,	// Time synchronization ping (unreliable)
	SOP_TIME_PONG,	// Time synchronization pong (unreliable)
	SOP_DATA,		// Data (reliable or unreliable)
	SOP_FRAG,		// Data fragment (reliable); initial fragment begins with 32-bit total length
	SOP_ACK,		// Acknowledgment of reliable, ordered messages (unreliable)
	SOP_NAK			// Negative-acknowledgment of reliable, ordered messages (unreliable)
};

// Transport modes
enum TransportModes
{
	MODE_UNRELIABLE,	// Out-of-band, unreliable transport
	MODE_RELIABLE		// In-band, reliable, ordered transport
};


//// sphynx::Transport

class Transport
{
protected:
	static const u32 TIMEOUT_DISCONNECT = 15000; // 15 seconds

	static const u32 MINIMUM_MTU = 576; // Dialup
	static const u32 MEDIUM_MTU = 1400; // Highspeed with unexpected overhead, maybe VPN
	static const u32 MAXIMUM_MTU = 1500; // Highspeed

	static const u32 IPV6_HEADER_BYTES = 40;
	static const u32 IPV4_HEADER_BYTES = 20;
	static const u32 UDP_HEADER_BYTES = 8;

	// Maximum transfer unit (MTU) in UDP payload bytes, excluding the IP and UDP headers and encryption overhead
	u32 _max_payload_bytes;

public:
	void InitializePayloadBytes(bool ip6);

protected:
	// Receive state: Next expected ack id to receive
	u32 _next_recv_expected_id;

	// Receive state: Fragmentation
	u8 *_fragment_buffer; // Buffer for accumulating fragment
	u32 _fragment_offset; // Current write offset in buffer
	u32 _fragment_length; // Number of bytes in fragment buffer

	static const u32 FRAG_MIN = 2;		// Min bytes for a fragmented message
	static const u32 FRAG_MAX = 256000;	// Max bytes for a fragmented message

	// Receive state: Receive queue
	struct RecvQueue
	{
		static const u32 FRAG_FLAG = 0x80000000;
		static const u32 BYTE_MASK = 0x7fffffff;

		RecvQueue *next;	// Next in queue
		u32 id;				// Acknowledgment id
		u32 bytes;			// High bit: Fragment?

		// Message contents follow
	};

	// Receive state: Receive queue head
	RecvQueue *_recv_queue_head; // Head of queue for messages that are waiting on a lost message

protected:
	void QueueRecv(u8 *data, u32 bytes, u32 ack_id, bool frag);

protected:
	// Send state: Next ack id to use
	u32 _next_send_id;

	// Send state: Buffered writes
	u8 *_send_buffer;
	u32 _send_buffer_bytes;
	u32 _send_buffer_offset;

	// Send state: Send queue
	struct SendQueue
	{
		static const u32 FRAG_FLAG = 0x80000000;
		static const u32 BYTE_MASK = 0x7fffffff;

		SendQueue *next; // Next in queue
		u32 id; // Acknowledgment id
		u32 bytes; // High bit: Fragment?

		// Message contents follow
	};

	// Queue of messages that are waiting to be sent
	SendQueue *_send_queue_head, *_send_queue_tail;

	// List of messages that are waiting to be acknowledged
	SendQueue *_sent_list_head;

	Mutex _send_lock;

protected:
	// Called whenever a connection-related event occurs to simulate smooth
	// and consistent transmission of messages queued for delivery
	void TransmitQueued();

public:
	Transport();
	virtual ~Transport();

	static const int TICK_RATE = 20; // 20 milliseconds

public:
	void BeginWrite();
	u8 *GetReliableBuffer(u32 data_bytes, SuperOpCode sop);
	u8 *GetUnreliableBuffer(u32 data_bytes, SuperOpCode sop);
	void FlushWrite();

protected:
	void TickTransport(ThreadPoolLocalStorage *tls, u32 now);
	void OnSuperMessage(u16 super_opcode, u8 *data, u32 data_bytes);
	void OnDatagram(u8 *data, u32 bytes);
	void OnFragment(u8 *data, u32 bytes, bool frag);

protected:
	bool PostMTUDiscoveryRequest(ThreadPoolLocalStorage *tls, u32 payload_bytes);
	void PostTimePing();

protected:
	virtual void OnMessage(u8 *msg, u32 bytes) = 0;
	virtual bool PostPacket(u8 *data, u32 buf_bytes, u32 msg_bytes) = 0;
	virtual void OnTimestampDeltaUpdate(u32 rtt, s32 delta) {}
};


} // namespace sphynx


} // namespace cat

#endif // CAT_SPHYNX_TRANSPORT_HPP
